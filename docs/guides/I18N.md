# gRPC i18n Pattern

This guide explains how internationalization (i18n) is implemented for gRPC error messages using the metadata pattern.

## Overview

Language is passed via gRPC Metadata (`accept-language` header) instead of adding `lang` field to every proto message. This keeps proto definitions clean and follows HTTP header conventions.

## Architecture

```
Gateway                              Auth Service
   │                                      │
   │  gRPC Call                           │
   │  + Metadata: accept-language=tr      │
   │ ────────────────────────────────────>│
   │                                      │
   │                      ┌───────────────┴───────────────┐
   │                      │ Context Interceptor           │
   │                      │ - Extract locale from metadata│
   │                      │ - Set RequestContext          │
   │                      └───────────────┬───────────────┘
   │                                      │
   │                      ┌───────────────┴───────────────┐
   │                      │ Handler                       │
   │                      │ - Process business logic      │
   │                      │ - Call createGrpcErrorResponse│
   │                      └───────────────┬───────────────┘
   │                                      │
   │                      ┌───────────────┴───────────────┐
   │                      │ Error Handler                 │
   │                      │ - Get locale from context     │
   │                      │ - Translate error message     │
   │                      └───────────────┬───────────────┘
   │                                      │
   │  Response (translated error)         │
   │ <────────────────────────────────────│
```

## Key Components

### 1. RequestContext (Auth Service)

Location: `src/shared/context/RequestContext.ts`

Uses Node.js AsyncLocalStorage to store request-scoped data:

```typescript
import { AsyncLocalStorage } from 'async_hooks';

interface RequestContextData {
  locale: string;
  requestId?: string;
}

class RequestContextClass {
  private storage = new AsyncLocalStorage<RequestContextData>();

  run<T>(data: RequestContextData, fn: () => T): T {
    return this.storage.run(data, fn);
  }

  getLocale(): string {
    return this.storage.getStore()?.locale || 'en';
  }
}

export const RequestContext = new RequestContextClass();
```

### 2. Context Interceptor (Auth Service)

Location: `src/grpc/interceptors/contextInterceptor.ts`

Wraps handlers to extract locale and set context:

```typescript
export function wrapHandlersWithContext(handlers: HandlerMap): HandlerMap {
  const wrapped: HandlerMap = {};

  for (const [name, handler] of Object.entries(handlers)) {
    wrapped[name] = (call, callback) => {
      const locale = extractLocaleFromMetadata(call.metadata);

      RequestContext.run({ locale }, () => {
        handler(call, callback);
      });
    };
  }

  return wrapped;
}

function extractLocaleFromMetadata(metadata: grpc.Metadata): string {
  const acceptLanguage = metadata.get('accept-language');
  return acceptLanguage?.[0]?.toString() || 'en';
}
```

### 3. Error Handler (Auth Service)

Location: `src/shared/errors/grpcErrorHandler.ts`

Automatically uses locale from context:

```typescript
export function createGrpcErrorResponse(error: unknown, fallbackType: string) {
  const locale = RequestContext.getLocale(); // No parameter needed!
  const message = translateError(error, locale);
  return { success: false, error: message };
}
```

### 4. Gateway Client

Location: `lobsterlead-gateway/src/infra/clients/BaseGrpcClient.ts`

Sends locale via metadata:

```typescript
private executeCall<TRequest, TResponse>(
  methodName: string,
  request: TRequest,
  locale?: string
): Promise<TResponse> {
  const metadata = new grpc.Metadata();
  if (locale) {
    metadata.set('accept-language', locale);
  }

  method.call(this.client, request, metadata, { deadline }, callback);
}
```

## Usage

### Handler (No lang parameter needed)

```typescript
async function signIn(call, callback): Promise<void> {
  const { email, password } = call.request; // No 'lang' field

  try {
    const result = await loginUseCase.execute({ email, password });
    callback(null, { success: true, user: result.user });
  } catch (error) {
    // Locale is auto-extracted from context
    callback(null, createGrpcErrorResponse(error, 'LOGIN_FAILED'));
  }
}
```

### Gateway Call

```typescript
async signIn(data: { email: string; password: string; lang?: string }) {
  const grpcRequest = { email: data.email, password: data.password };

  return this.callWithFallback({
    methodName: 'SignIn',
    grpcMethod: (req, locale) => this.grpcClient.signIn(req, locale),
    request: grpcRequest,
    locale: data.lang,  // Passed via metadata, not request body
  });
}
```

## Supported Languages

- `en` - English (default)
- `tr` - Turkish

## Adding New Services

1. Copy `RequestContext.ts` to new service
2. Copy `contextInterceptor.ts` to new service
3. Update `createGrpcErrorResponse` to use `RequestContext.getLocale()`
4. Wrap handlers in `server.ts`:
   ```typescript
   const wrappedHandlers = wrapHandlersWithContext(handlers);
   server.addService(AuthService, wrappedHandlers);
   ```
5. Gateway already sends locale via metadata - no changes needed

## Translation File Structure

Translations are stored in JSON files under `src/shared/i18n/locales/`:

```
src/shared/i18n/
├── index.ts         # Main module with t() function
├── types.ts         # Type definitions for translation keys
└── locales/
    ├── tr.json      # Turkish translations
    └── en.json      # English translations
```

### JSON File Format

```json
{
  "common": {
    "internalError": "An unexpected error occurred. Please try again later.",
    "validationError": "Invalid request. Please check your input.",
    "notFound": "The requested resource was not found."
  },
  "auth": {
    "loginFailed": "Invalid email or password.",
    "registrationFailed": "Registration failed. Please try again."
  }
}
```

### Using Translations

```typescript
import { t } from '../shared/i18n/index.js';

// Uses locale from RequestContext automatically
const message = t('common.notFound');

// Or with explicit locale
const message = t('common.notFound', 'tr');
```

### Adding New Translation Keys

1. Add the key to `types.ts`:
```typescript
export type AuthTranslationKey =
  | 'auth.loginFailed'
  | 'auth.newKey';  // Add here

export type TranslationKey = CommonTranslationKey | AuthTranslationKey;
```

2. Add translations to both JSON files:
```json
// tr.json
{ "auth": { "newKey": "Türkçe mesaj" } }

// en.json
{ "auth": { "newKey": "English message" } }
```

3. If mapping from error messages, add to `ERROR_MESSAGE_TO_KEY`:
```typescript
export const ERROR_MESSAGE_TO_KEY: Record<string, TranslationKey> = {
  'my error message': 'auth.newKey',
};
```

## Best Practices

1. **Never add `lang` field to proto messages** - use metadata instead
2. **Always use `RequestContext.getLocale()`** in error handlers
3. **Default to 'tr'** when locale is not provided (Turkish is the default)
4. **Keep translations in JSON files** under `src/shared/i18n/locales/`
5. **Use type-safe keys** - always add new keys to `types.ts`
6. **Group translations by domain** - e.g., `common.`, `auth.`, `workspace.`
